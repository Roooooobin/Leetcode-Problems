#include <bits/stdc++.h>
using namespace std;
/*
 近期某商场由于周年庆，开启了“0元购”活动。活动中，消费者可以通过组合手中的代金券，实现0元购买指定商品。
聪明的小团想要用算法来帮助他快速计算：对于指定价格的商品，使用代金券凑出其价格即可，但所使用的代金券总面额不可超过商品价格。由于代金券数量有限，使用较少的代金券张数则可以实现价值最大化，即最佳优惠。
假设现有100元的商品，而代金券有50元、30元、20元、5元四种，则最佳优惠是两张50元面额的代金券；而如果现有65元的商品，则最佳优惠是两张30元代金券以及一张5元代金券。
请你帮助小团使用一段代码来实现代金券计算。

 多组输入输出，读到s=0时结束
输入可以有多个测试样例，每个测试由两行组成。
其中第一行包含一个整数P，表示商品的价格，1≤P≤10000；输入P为0时表示结束。
第二行包含若干整数，使用空格分割。其中第一个整数N（1≤N≤20）表示有多少种代金券，其后跟随M个整数，表示手中持有的代金券面额（1≤N≤1000），每种代金券数量不限。

 找到最少张数的代金券，使其面额恰好等于商品价格。输出所使用的代金券数量；
如果有多个最优解，只输出其中一种即可；
如果无解，则需输出“Impossible”。

65
4 50 30 20 5
0
 */
int main() {
    int s;
    while(cin >> s && s){
        int n;
        cin >> n;
        vector<int> coupons;
        int x;
        for(int i=0; i<n; i++){
            cin >> x;
            coupons.push_back(x);
        }
        vector<int> dp(s+1, s+100);
        dp[0] = 0;
        for(int i=0; i<n; i++){
            for(int j=coupons[i]; j<=s; j++){
                dp[j] = min(dp[j], dp[j-coupons[i]]+1);
            }
        }
        if(dp[s] == s+100){
            cout << "Impossible" << endl;
        }
        else{
            cout << dp[s] << endl;
        }
    }
    return 0;
}
